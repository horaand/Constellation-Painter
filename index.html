<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Constellation Painter</title>
<style>
  :root { color-scheme: dark; }
  html, body { height: 100%; margin: 0; background:#05060a; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; display: block; }
  .ui {
    position: fixed; left: 1rem; bottom: 1rem; z-index: 2;
    display: flex; flex-wrap: wrap; gap: .5rem;
    background: rgba(12,16,28,.35); border:1px solid rgba(170,190,255,.18);
    padding:.7rem .8rem; border-radius:12px; backdrop-filter: blur(6px);
  }
  button, .chip {
    appearance: none; border-radius: 10px; border:1px solid rgba(170,190,255,.3);
    background: rgba(170,190,255,.1); color:#e8ecff; padding:.45rem .7rem; cursor: pointer; font-size:.9rem;
  }
  .chip { user-select: none }
</style>
</head>
<body>
<canvas id="stage"></canvas>

<div class="ui">
  <button id="toggleLines">Toggle constellations</button>
  <button id="addRandom">Add 50 stars</button>
  <button id="clear">Clear stars</button>
  <span class="chip" id="hint">Click anywhere to add a star âœ¨</span>
</div>

<script>
/* ===== Constellation Painter (no libraries) ===== */
const cvs = document.getElementById('stage');
const ctx = cvs.getContext('2d', { alpha: true });
const DPR = Math.min(devicePixelRatio || 1, 2);

let W=0,H=0; let stars=[]; 
let showLines = true;
let tick = 0;

// Resize canvas for DPR
function fit() {
  W = innerWidth; H = innerHeight;
  cvs.style.width = W+'px'; cvs.style.height = H+'px';
  cvs.width = Math.floor(W*DPR); cvs.height = Math.floor(H*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', fit, {passive:true}); fit();

// Utility
const rnd = (a,b)=>Math.random()*(b-a)+a;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

function seed(n=220){
  for(let i=0;i<n;i++){
    stars.push(makeStar(Math.random()*W, Math.random()*H));
  }
}
function makeStar(x,y){
  // size slightly biased toward smaller dots
  const depth = Math.random(); // 0..1
  return {
    x,y,
    r: 0.5 + Math.pow(1-depth,1.4)*1.7,
    base: rnd(.25,.9),
    hue: rnd(205,265),
    phase: rnd(0,Math.PI*2),
    twinkle: rnd(.6,1.7)
  };
}

// Nearest neighbors (k=2) with distance cap to avoid long edges
function nearestPairs(list, maxDist=140){
  const lines = [];
  for (let i=0;i<list.length;i++){
    // find two nearest
    let n1=-1,d1=1e9, n2=-1,d2=1e9;
    for (let j=0;j<list.length;j++){
      if(i===j) continue;
      const dx=list[i].x-list[j].x, dy=list[i].y-list[j].y;
      const d= Math.hypot(dx,dy);
      if (d<d1){ n2=n1; d2=d1; n1=j; d1=d; }
      else if (d<d2){ n2=j; d2=d; }
    }
    if (d1<maxDist) lines.push([i,n1,d1]);
    if (d2<maxDist) lines.push([i,n2,d2]);
  }
  // remove duplicates (i->j and j->i)
  const key = (a,b)=> a<b? a+'-'+b : b+'-'+a;
  const seen = new Set();
  return lines.filter(([a,b])=>{
    const k = key(a,b);
    if (seen.has(k)) return false;
    seen.add(k); return true;
  });
}

function draw(){
  tick += 1/60;

  // Clear with subtle vignette
  ctx.clearRect(0,0,W,H);
  const grd = ctx.createRadialGradient(W*.7,H*.2,0,W*.7,H*.2, Math.hypot(W,H)*.8);
  grd.addColorStop(0,'rgba(25,38,76,.35)');
  grd.addColorStop(1,'rgba(2,3,8,0)');
  ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

  // Twinkling stars
  for(const s of stars){
    const a = clamp(s.base * (0.55 + 0.45 * Math.sin(tick*s.twinkle + s.phase)), .06, 1);
    ctx.save();
    ctx.globalAlpha = a;
    ctx.shadowColor = `hsla(${s.hue} 100% 85% / .9)`;
    ctx.shadowBlur = s.r*5.5;
    ctx.fillStyle = `hsl(${s.hue} 95% 94%)`;
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Constellation lines
  if (showLines && stars.length>1){
    const lines = nearestPairs(stars, 140);
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    for(const [ia, ib, d] of lines){
      const sa = stars[ia], sb = stars[ib];
      const k = clamp(1 - d/150, 0, 1);
      const pulse = 0.6 + 0.4*Math.sin(tick*1.5 + (ia+ib));
      ctx.globalAlpha = k * 0.45 * pulse;
      ctx.strokeStyle = 'rgba(210,230,255,.9)';
      ctx.lineWidth = 0.6 + 1.2*k;
      ctx.beginPath(); ctx.moveTo(sa.x, sa.y); ctx.lineTo(sb.x, sb.y); ctx.stroke();
    }
    ctx.restore();
  }

  requestAnimationFrame(draw);
}
seed(240);
requestAnimationFrame(draw);

// Interactions
addEventListener('click', (e)=>{
  stars.push(makeStar(e.clientX, e.clientY));
});
document.getElementById('toggleLines').onclick = ()=> showLines = !showLines;
document.getElementById('addRandom').onclick = ()=> seed(50);
document.getElementById('clear').onclick = ()=> stars.length = 0;
</script>
</body>
</html>
